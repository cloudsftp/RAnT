#+title: RAnT

A Rust library for numerical simulation of non-linear systems.

** Idea

This library aims to be an alternative to other numerical simulators.
The tool [[https://github.com/cloudsftp/AnT][AnT]], that I was using extensively during my [[https://github.com/cloudsftp/Masterarbeit][masters thesis]], is the inspiration for this project.

In contrast to the tool mentioned above, with this library one writes the function of interest in rust code and passes it to the appropriate library functions for simulation and analysis.
We hope to achieve performance improvements through compiler optimizations and static linking.

** Roadmap [7/10]

1. [X] Simulate 1D floating-point R -> R functions
   - Cycles and Periods
2. [X] Scanning parameters 1D
3. [X] Test performance of generic S -> S functions
4. [X] Test logistic period results
5. [X] ND scans
6. [X] Write result to file
7. [X] Parallelization
8. [-] More scanning options
   - [ ] initial states (keep from last scan point)
   - [X] multi dimensional for both initial states and parameters
9. [-] Image generation
   - [X] prototype
   - [ ] library
10. [ ] Interactive image generation (zoom and pan)

* Design decisions

** Implementation of extra library functions for 1D functions

A benchmarking of a generic implementation and a static implementation for 1D functions found no significant difference (58ms vs. 60ms).
Suprisingly, the generic implementation was a little faster.
Therefore, we will only keep the generic implementation for improved maintenance.

** Parallelization

The concept for parallelization is not fully developed yet.
But there are some criteria that are clear at this point:

- Concurrency primitives from [[https://en.wikipedia.org/wiki/Communicating_sequential_processes][CSP]] (think channels from go)
- Each thread computes one line sequentially at a time
  - Somehow need to configure direction
  - Need to reset initial state after every line

** History array for cycle detection (not used anymore)

A benchmarking analysis of the three alternatives
1. stack
2. heap
3. heap whith reuse of vector
found that option 1 is the fastest for small sizes of the history array.
For larger sizes, option 2 is the best.

Since option 2 is also easier to implement than the other options, it is chosen for this project.
Option 1 would require macros and option 3 the appropriate creation of vectors (one per thread) and passing them as mutable references.
